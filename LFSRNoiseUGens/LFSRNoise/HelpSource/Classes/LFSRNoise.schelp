class:: LFSRNoise
summary:: 32-bit linear feedback shift register (LFSR) noise
related:: Classes/LFClipNoise, Classes/LFDClipNoise, Classes/LFDNoise0, Classes/LFDNoise1, Classes/LFDNoise3, Classes/LFNoise0, Classes/LFNoise1, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Pseudo-random noise that generates the values -1 or +1 at a rate given by the nearest
integer division of the sample rate by the  code::freq:: argument.
Probably not great for your speakers at high amplitudes. You may wish to use  code::LeakDC():: for low-frequency audio, as the raw output will likely result in lengthy periods of DC offset.

classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate values.

argument::fbPos
Bitwise index (1-31) to insert new values. Related to number of samples per LFSR cycle.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

SUBSECTION:: Notes
To produce a pseudo-random number sequence, the noise generator performs a bitwise XOR on the two least-significant bits of a 32-bit integer, shifts all bits one position to the right, and inserts the result of the XOR at code::fbPos::. The UGen outputs the right-most bit (LSB) of the integer, scaled to Â±1.
Because the state of the LFSR must always be a non-zero integer to produce new values, the UGen sets all bits to 1 if the sequence produces an integer value of 0.

The result is a periodic waveform capable of sounds ranging from noise to harmonically rich tones.

Examples::

code::

//defaults
{LFSRNoise.ar(500, 14)}.play;

//modulate frequency
{LFSRNoise.ar(XLine.kr(1000, 10000, 10), 14)}.play;

//modulate fbPos
{LFSRNoise.ar(1000, Line.kr(1, 31, 10) )}.play;

//mouse freq
{LFSRNoise.ar( MouseX.kr(1, SampleRate.ir, 1) )}.play;

//mouse fbPos
{LFSRNoise.ar( SampleRate.ir, MouseX.kr(1, 31) )}.play;

//mouse reign supreme
{LFSRNoise.ar( MouseY.kr(100, 10000, 1), MouseX.kr(1, 31) )}.play;

//use as a frequency control
{SinOsc.ar(LFSRNoise.kr(10, 3, 200, 600) )}.play;


(
SynthDef(\help_LFSRNoise, {
    var sig = LFSRNoise.ar(\freq.kr(440), \fbPos.kr(14), \amp.kr(0.8));
    var env = Env.asr(\atk.kr(0.01), 1, \rel.kr(0.01), \lin).ar(2, \gate.kr(1)).round(15.reciprocal);
    sig = LeakDC.ar(sig);
    sig = sig * env;
    sig = Pan2.ar(sig, \pan.kr(0));
    Out.ar(\out.kr(0), sig);
}).add;
)

//8 bit rave
(
t = TempoClock(3);
PmonoArtic(
	\help_LFSRNoise,
	\dur, Pdup(Prand((4..5), inf), Prand([0.25, 0.5], inf)),
	\freq, Pdup(Prand((4..5), inf), Pwhite(1,20)) * 500,
	\fbPos, Pdup(Prand((4..5), inf), Pwhite(2, 15)),
).play(t);
)

//bass line oscillator
(
t = TempoClock(2.5);
PmonoArtic(
	\help_LFSRNoise,
	\dur, Prand([Pseq(0.5!2), Pseq([1]), Pseq(0.25!4)], inf),
	\scale, Scale.at(\minorPentatonic),
	\degree, Pwhite(0,10),
	\octave, 6,
	\fbPos, 4
).play(t);
)
::
